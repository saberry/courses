---
title: "Unstructured Data Analytics"
description: |
  Important Programming Ideas
output:
  distill::distill_article:
    toc: true
    toc_depth: 2
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
```

## Some I/O For Your Information

### disk.frame & dask

In R, you might want to check out <a href="https://github.com/xiaodaigh/disk.frame">disk.frame</a>; for Python, <a href="https://dask.org/">dask</a> is what you need.

### Apache Arrow 

- feather

- parquet

```{r, eval = FALSE}
library(arrow)

read_arrow()

read_parquet()

write_arrow()

write_parquet()
```

```{python, eval = FALSE}
import pandas as pd

import pyarrow

pd.read_feather()

pd.read_parquet()

pyarrow.feather.write_feather
```


## Efficient Looping

You like for loops? That's cool, just do them efficiently with `doParallel` and `foreach`.

```{r}
library(doParallel)

library(foreach)

library(randomForest)

tuning_params <- expand.grid(ntree = seq(100, 1000, by = 10), 
                             mtry = 1:4)

t1 <- proc.time()
rf <- for(i in 1:nrow(tuning_params)) {
    rfMod <- randomForest(Species ~ ., data= iris,
                          ntree = tuning_params[i, "ntree"],
                          mtry = tuning_params[i, "mtry"])
    
    data.frame(ntree = tuning_params[i, "ntree"],
               mtry = tuning_params[i, "mtry"],
               oobError = rfMod$err.rate[nrow(rfMod$err.rate), 1])
    
}
proc.time() - t1
```

Fine for a silly example, but let's provide some power to this:

```{r}
cl <- makeCluster(detectCores() - 1)

registerDoParallel(cl)

t1 <- proc.time()
rf <- foreach(i = 1:nrow(tuning_params), 
              .packages='randomForest') %dopar%
  {
    rfMod <- randomForest(Species ~ ., data= iris,
                          ntree = tuning_params[i, "ntree"],
                          mtry = tuning_params[i, "mtry"])
    
    data.frame(ntree = tuning_params[i, "ntree"],
               mtry = tuning_params[i, "mtry"],
               oobError = rfMod$err.rate[nrow(rfMod$err.rate), 1])
    
  }
proc.time() - t1  

stopCluster(cl)
```

It really doesn't get any easier than this...except if you just let `caret` handle all of this for you.

You've already seen this, but here it is again:

```{r}
cl <- makeCluster(detectCores() - 1)

clusterExport(cl, c("tuning_params", "iris"))

clusterEvalQ(cl, library(randomForest))

t1 <- proc.time()
rf <- parLapply(cl, 1:nrow(tuning_params), function(i) {
  rfMod <- randomForest(Species ~ ., data= iris,
                          ntree = tuning_params[i, "ntree"],
                          mtry = tuning_params[i, "mtry"])
    
    data.frame(ntree = tuning_params[i, "ntree"],
               mtry = tuning_params[i, "mtry"],
               oobError = rfMod$err.rate[nrow(rfMod$err.rate), 1])
})
proc.time() - t1  

stopCluster(cl)
```

This can be extended to mapply, sapply, among others.

Bust out some of your own code and see if you can make it work faster!

```{python}
from joblib import Parallel, delayed
from sklearn.ensemble import RandomForestClassifier
import numpy as np

def train_model(X, y, seed):
    model = LinearSVC(random_state=seed)
    return model.fit(X, y)

X = np.array([[1,2,3],[4,5,6]])
y = np.array([0, 1])
result = Parallel(n_jobs=4)(delayed(train_model)(X, y, seed) for seed in range(10))
# result is a list of 10 models trained using different seeds

```


## Exception/Error Handling

Try this code:

```{r}
numbers <- list(1, 2, 3, "4")

adderFunction <- function(x) {
  x + 4
}

lapply(1:length(numbers), function(x) adderFunction(numbers[[x]]))
```

How would you fix this?

```{r}
yourFunction <- function(nums) {
    out <- tryCatch(
        {
          # What you want to happen
        },
        error = function(cond) {
          # What you worry will happen
          # and what you will return
        },
        warning = function(cond) {
          # Just in case, 
          # but not required
        },
        finally = {
          # Not necessary, but will
          # execute no matter what.
        }
    )    
    return(out)
}

y <- lapply(numbers, yourFunction)
```


```{python}
try:
    f = open('myfile.txt')
    s = f.readline()
    i = int(s.strip())
except OSError as err:
    print("OS error: {0}".format(err))
except ValueError:
    print("Could not convert data to an integer.")
except:
    print("Unexpected error:", sys.exc_info()[0])
    raise
```

